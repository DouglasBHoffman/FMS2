Forth Meets Smalltalk (FMS)MI version 4.1b January 28, 2012Douglas B. Hoffman=============================WHAT IS FMS?=============================FMS stands for Forth Meets Smalltalk. Presented here is a "specification" for the FMS Forth object programming extension.  An implementation of the specification can be done in different ways as long as the behaviors adhere to the specification.  I provide three example reference implementations, each using different implementation techniques with each technique having relative strengths and weaknesses.  The *use* of each implementation, however, is identical (except for a few multiple inheritance behaviors).  Note that this is not a proposal for a Forth ANS standard, although I suppose it could be used as one.=============================OPEN, EXTENSIBLE, FLEXIBLE=============================The complete source is freely provided for FMS and that source is written in (essentially 100%) ANS compliant Forth.  Since Forth itself is open, extensible, and flexible then FMS is as well.  One can add or remove as many behaviors/features as desired.

=============================THE FMS SYSTEM=============================The following describes the fundamentals of objects, classes, and messaging as used and implemented by the FMS object system.

Object-oriented programming techniques are built around objects.  An object associates data with the particular operations that can use or affect that data.  FMS provides a data type to identify an object variable without specifying a particular class of the object.
An object associates data with the particular operations that can use or affect that data. In FMS, these operations are known as the object’s methods; the data they affect are its instance variables (called ivars for short). In essence, an object bundles a data structure (instance variables) and a group of procedures (methods) into a self-contained programming unit.

1) Encapsulation.  An object’s instance variables are internal to the object; generally, you get access to an object’s ivars only through the object’s methods. For others to find out something about an object, there has to be a method to supply the information. For example, a rectangle would have methods that reveal its size and position. (Actually, FMS provides ways to bypass this safety mechanism.  Use these at your own risk.)

Moreover, an object sees only the methods that were designed for it; it can’t mistakenly perform methods intended for other types of objects. Just as a Forth definition protects its local variables, hiding them from the rest of the program, an object hides both its instance variables and its method implementations.

2) Dynamic Binding. A method is invoked on an object only by sending a message to the object.  The object itself determines what code gets executed by looking up the method at run time in a table or list associated with the message and object.  A crucial difference between Forth function calls(words that perform an action) and messages is that a function and its parameters are joined together in the compiled code, but a message and a receiving object aren’t united until the program is running and the message is sent. Therefore, the exact method invoked to respond to a message can only be determined at runtime, not when the code is compiled (let's assume all late binding for now, early binding is just a special case and will be discussed later).
3) Polymorphism.  Messages in FMS appear in the same syntactic positions as typical Forth function calls: that is messages are words that perform an action on data items (objects and parameters) passed to it on the stack.  But, because the invoked methods “belong to” an object, messages don’t behave in the same way that function calls do:  In particular, an object can be operated on by only those methods that were defined for it. It can’t confuse them with methods defined for other kinds of objects, even if another object responds to a message with the same name.

This feature, referred to as polymorphism, plays a significant role in object programming.  Together with dynamic binding, it permits you to write code that might apply to any number of different kinds of objects, without you having to choose at the time you write the code what kinds of objects they might be. They might be objects that will be developed later, by other programmers working on other projects.  If you write code that sends a 'display' message to an object in an an object container, any object that has a display method is a potential receiver (since the type of object in the container can be changed dynamically as the program runs).
4) Inheritance.  Class definitions are additive; each new class that you define is based on another class from which it inherits methods and instance variables. The new class simply adds to or modifies what it inherits. It doesn’t need to duplicate inherited code.

Inheritance links all classes together in a hierarchical tree with a single class at its root.  Every class (except the root class = object) has a superclass one step nearer the root, and any class (including class object) can be the superclass for any number of subclasses one step farther from the root.
5) Open Recursion. A special variable called 'self' allows a method body to invoke another method body of the same object. In FMS this variable can be late-bound or early bound; if late bound it allows a method defined in one class to invoke another method that is defined later, either in the same class or some subclass thereof.


FMS provides all of the five items above, and a lot more.The ability to late-bind messages to 'self'(open recursion) when constructing a new class is like "factoring on steroids" (thanks to Bernd Paysan for that quote).  The ease of code modification and re-use through subclassing and late-binding to SELF can be truly astounding.

All serious Forth OOP extensions will provide at least the above capabilities, in the opinion of this author.

ALL object programming ultimately distills to sending messages to objects.  There may or may not be parameter(s) to be included with the messages.  Parameter(s) may or may not be returned.  At this very fundamental level all object systems are the same.  Objects and messages.  So, in essence, the only difference between the various object extensions is how objects and messages(methods) are created.  Class based?  Prototype based?  Metaobject protocol based?  Other?  Regardless of this it will always come down to objects and messages, and the ease of creating each.The ability to create and work with nameless objects in the heap is an important feature.  If you look at the FMS example "A-Way-to-File" you will see that a record object contains 4 (or maybe more) nameless string objects instantiated in the heap.  The database itself is made up of nameless record objects that also exist in the heap.  There are 26 records initially, each record with 4 strings, or 104 string objects and 26 record objects.  These numbers grow or shrink in a highly dynamic manner.  The use of pre-defined object types that can be easily cast in the heap (and so just as easily discarded) makes the program easy to write, debug, and modify.  The record objects are kept in an expandable/shrinkable container object of class OBJECT-LIST.
Forth is not Smalltalk.  Everything is *not* an object.  Normal Forth code and objects must get along together seamlessly or the advantage of adding objects to Forth is lost.  For example, one should be able to write a normal Forth word that can receive and act on any object passed to it via the stack without having to resort to treating the stack item (object) in a special way.  The Forth word should be able to directly and simply send any message to any passed-in object.  For example:: foo ( object -- )   PRINT:   ;  \ print: is a message that will be sent to the passed-in objectFoo should work for any class of object that "understands" the PRINT: message.  Foo should work even on object types (classes) that have yet to be written.  The only requirement is that the newly written class/object understand the message PRINT: .   How each different class of object responds to print: can of course vary infinitely.The classic example of the usefulness of dynamic dispatch is for a GUI application.  Consider the drawing of a window and its contents (buttons, strings, pictures, etc.).  A list of all objects existing in the window is maintained.  When it is time to draw the window then the DRAW: message is sent to all objects in the list.  When the window is deactivated such as switching to another window the DEACTIVATE: message is sent to each object in the list.  When a mouse click on the window occurs then the HIT?: message is sent to each object in the list until a true is returned.  The CLICK: message is then sent to just that object.  This entire framework is written without any knowledge of what type of objects could be in the list.=============================WHAT IS NEW IN THIS VERSION?=============================

An ANS-compatible "dot parser" is provided for methodless ivar access.
See the examples at the end of the MI "Torture Test" file.Version 4.x adds multiple inheritance(MI) support, and is 100% backwards-compatible with previous (single inheritance) versions of FMS.  Any source that loads under FMS 1.x or 3.x will also correctly load under FMS-MI 4.x.The only added syntax for MI is the SUPER{ ... } declaration list which can contain any number of superclasses, but at least one.  It replaces the <SUPER word (although <SUPER can still be optionally used for SI).  Note that this is the same syntax as used in Mops.  Essentially, the Mops MI syntax and method/ivar inheritance hierarchy scheme is used in FMS 4.x.The rules for resolving ambiguity, when inherited methods and ivar names conflict, are simple.  The FMS object system will first search the base class (the new class being defined) for methods and ivars.  If not found then the search will proceed to the first superclass, the first in the SUPER{...} list read left-to-right.  The search will continue if necessary to the superclasses of each and then on to the next superclass to the right and its superclasses and so on.  The superclass search order is from left-to-right (but all nested superclasses, multiply inherited or not, are first searched before moving on to the next primary superclass in the SUPER{ ... } list).  As soon as the method or ivar is found then the searching stops.Consider the following example class structure and hierarchy::class sup1     \ "<super object" is implicit  cell bytes x  :m !: ( n -- ) x ! ;m  :m @: ( -- n ) x @ ;m;class:class sup2  cell bytes x  :m !: ( n -- ) x ! ;m  :m @: ( -- n ) x @ ;m;class:class base super{ sup1 sup2 }  cell bytes x  :m !: ( n -- ) x ! ;m  :m @: ( -- n ) x @ ;m;classNote the name conflicts in all three classes for the ivar name "x" and the message names "!:" and "@:".  With single inheritance(SI) FMS, duplicate ivar names are not allowed.  But with MI we remove this restriction because it is often inconvenient to go back and review all ivar names used in each multiply inherited superclass and any superclasses of those superclasses etc.  While we do not recommend purposely using conflicting ivar names, it is not restricted and will not cause technical problems.Message name clashes, or method over riding, has always been allowed in subclasses and is in fact needed when changing the behavior of a subclass.We call SUP1 and SUP2 primary superclasses of class BASE.  Superclasses of SUP1 and SUP2 are secondary (or tertiary, etc.) superclasses of class BASE.  Note that classes SUP1 and SUP2 may themselves have multiple superclasses and so on.  There are no limits on this depending on the number of wordlists and size of the search order allowed in a particular Forth.As it is written, class BASE doesn't make sense because it has sealed off the ivars and methods in its two superclasses.  One way to solve this is to define a class BASE' as follows::class base' super{ sup1 sup2 }  cell bytes x  :m !: ( n -- ) x ! ;m  :m @: ( -- n ) x @ ;m  :m !1: ( n -- ) super !: ;m \ direct the !: message to the first primary superclass ( sup1 in this case )  :m @1: ( -- n ) super @: ;m \ could have used "super> sup1 @:" instead  :m !2: ( n -- ) super> sup2 !: ;m \ direct the !: message to superclass sup2  :m @2: ( -- n ) super> sup2 @: ;m;classAnother way to achieve the same result is to use unique message names in the superclasses as follows::class sup1'  cell bytes x  :m !1: ( n -- ) x ! ;m  :m @1: ( -- n ) x @ ;m;class:class sup2'  cell bytes x  :m !2: ( n -- ) x ! ;m  :m @2: ( -- n ) x @ ;m;class:class base'' super{ sup1' sup2' }  cell bytes x  :m !: ( n -- ) x ! ;m  :m @: ( -- n ) x @ ;m;classAn object of class base'' will respond identically to messages as an object of class base'.For completeness, here is yet another way to achieve the same results by using unique ivar names::class sup1''  cell bytes x1  :m !: ( n -- ) x1 ! ;m  :m @: ( -- n ) x1 @ ;m;class:class sup2''  cell bytes x2  :m !: ( n -- ) x2 ! ;m  :m @: ( -- n ) x2 @ ;m;class:class base''' super{ sup1'' sup2'' }  cell bytes x  :m !: ( n -- ) x ! ;m  :m @: ( -- n ) x @ ;m  :m !1: ( n -- ) x1 ! ;m  :m @1: ( -- n ) x1 @ ;m  :m !2: ( n -- ) x2 ! ;m  :m @2: ( -- n ) x2 @ ;m;classAn object of class base''' will respond identically to messages as objects of classes base'' and base'.Note that in the case of multiple inheritance, the use of SUPER> is restricted to the primary superclasses.  But when using single inheritance SUPER> can be used with *any* superclass up the inheritance chain. =============================BACKGROUND=============================In the past few years I have written several different object extensions and looked closely at a few written by others.  What I have settled on is presented here and is a specification for what I believe to be an excellent and practical Forth object extension.  FMS is a distillation of the things liked most about the Neon-like approach with the objected-to parts "fixed".  There are strong opinions about what a Forth OO specification should be.  So I try to provide rationale for behavior decisions.FMS syntax often resembles Neon or Mops.  Andrew McKewan presented a Neon-like ANS Forth extension in 1997 (Object Oriented programming in ANS Forth, Forth Dimensions, March 1997).  Thanks to Michael Hore's excellent work with the Mops multiple inheritance object model, the FMS multiple inheritance object model has a solid basis for implementation and behavior.  

But there are major differences.  Object-message ordering, ANS compatibility, and ANS multiple inheritance are perhaps the most distinguishing features of FMS.

While there is nothing wrong with message-object, I agree that object-message ordering holds some inherent advantages particularly when making an ANS compatible extension.  Passing objects to other words, via the stack, and then sending messages to those objects is generally cleaner.  The syntax for sending messages to objects stored in locals and values is cleaner.Instance variables (ivars) can be easily be declared as embedded objects or declared using a generic ivar primitive.  This is the way Neon, Mops, SwiftForth's SWOOP, McKewan-97, and Win32Forth behave, and perhaps others.  The alternative would be to either not use objects-as-ivars, which I think would be a mistake, or to create the desired ivar object at instantiation time and manually store it in a container-type ivar.  The latter is inconvenient, tedious, and perhaps most importantly does not allow using embedded objects-as-ivars in dictionary based objects (unless one issues some kind of renew message at each programming session or each time a turnkey is launched).When defining a class, messages sent to self can either be early bound or late bound by using the SELF or [SELF] pseudo ivars respectively.  Some believe that all messages to self should be late bound and I understand the rationale for this belief.  But in practice I think that this is best specified by the programmer during the design of the classes.  Always using late binding to self is certainly the most general technique as it allows for maximum code reuse in subclasses.  But there is a performance cost because late binding is always slower than early binding.  Also, it is easy to just redefine specific superclass methods to use late binding to self when an opportunity becomes apparent for code reuse in a subclass.  This is the way Neon, Mops, SwiftForth's SWOOP, McKewan-97, and Win32Forth behave.  Besides, when methodless ivar access is used, instead of sending a message to the ivar, we have in essence "early bound" that part of the method definition.  So the only way to remain pure in terms of always having late bound messages to self is to only use messages when accessing instance variables.  This could be done with FMS as it is (FMS is very flexible and this decision is left to the individual programmer) but methodless ivar access, for non-complex ivar interaction, offers the advantages of speed and simplicity and also seems to be a desired feature by most Forth programmers.  I do not disagree.Note that messages sent to public objects are always late bound *unless* the object is a named dictionary object, where the compiler knows the class of the object, or if explicit early binding is invoked using CLASS_AS>.  Sending a message to an embedded ivar-as-object will also always be early bound because we do not expect the class of an ivar to change.  So where is the harm of early binding(faster) in this case?  But if we are using an ivar as a container of an object then messages sent to the "contents" of that container will be, and must be, late bound.Some claim that if we just make late binding fast enough then we should not care if late or early binding is used.  This sounds reasonable but in practice early binding will always have a noticeable speed advantage.  Classic OOP theory would require that any access to ivars only be done with a message send.  Classic OOP theory might also require that all message sends be late bound.  Well, this is Forth and at the individual programmer's choice we allow both of these "classic theory" rules to be broken (or not broken).=============================================THE SPECIFICATION of FMS IN GENERAL TERMS=============================================We will use Smalltalk terminology for most object related discussion and descriptions, especially the following terms:ClassObjectInstance Variable (or ivar for short)SubclassSuperclassInheritanceMessageMethodSELF  (pseudo ivar only used in method definitions)SUPER (pseudo ivar only used in method definitions)Message SendingEarly and Late binding of messages to methodsPolymorphism- FMS is a class-based (as opposed to prototype-based) multiple inheritance model.  Full inheritance of all methods and data (ivars) is achieved in subclasses.- A class is not an object.  It is best thought of as an object template or an "object factory".- Smalltalk-like duck typing is used.  Any message can be sent to any object.  If the message is not valid for that object then a "message not understood" error message is put up.- Message names can be ticked and the resulting xt used in the expected way on objects.- Named objects can also be ticked and the resulting xt used in the expected way.- When defining a class, creating a message name, creating the associated method code, and binding that message name to that code are all done in one step, as in Smalltalk and SWOOP.  There is no need to declare interfaces.  Interfaces are not used.- If a new method (message name) over rides an existing method then the FMS object system will just handle that implicitly, as in Smalltalk.  No manual programmer declaration of "override" or whatever is required.  The intent should be obvious. Over riding methods is a very common thing to do when defining new classes.- Declaring instance variables when defining a class includes the ability to simply declare the ivar as an object of an existing class.  The alternative would be to first declare a container ivar, then instantiate an object of the desired class, and finally storing that object in the container.  The latter can also easily be done with FMS if desired.- If an instance variable is declared to be of a certain class then messages sent to that ivar will always be early bound for efficiency (speed).  After all, we do not expect that the class of the ivar will change.- When defining a class it is the choice of the programmer to use early or late binding when sending a message to SELF.  If one insists that all messages to SELF be late bound, then what are we to make of methodless ivar accessing?  Giving the programmer full control over whether to use early or late binding, or no binding at all, seems to be more in the spirit of Forth programming.  Note that there is nothing inherent about FMS that prevents us from making all messages to self late bound (simply always use [SELF] instead of SELF).One other downside to always using late binding to [SELF] is the greater likelihood of infinite loops when a subclass method uses a superclass method which references back to the subclass via late binding.  In practice it has been the author's experience that when an opportunity for code reuse efficiency via late binding to self occurs, it is a simple matter to just redefine the superclass binding involved by changing SELF to [SELF] just for the particular method involved, taking care to not produce the infinite loop mentioned above.- Sending a message is a "special" event and it should be clear, when reading source code, when a message send occurs.  There are many ways to do this.  In FMS we require that all message names end in colon ( message: ).  Some seem fixated on wanting to hide the use of a message send thus making it indistinguishable from a normal Forth call.  This a mistake, in my opinion.  For example, if we define "@" to be a message then we can wind up with code that looks like the following:  foo @  \ a normal fetch from the VARIABLE foo, or the address presented by the execution of foo.  bar @  \ a message send (here, @ is a message) to the OBJECT bar, or the object presented by the execution of bar.What if we wish to apply the "normal" Forth word @ to whatever object bar leaves on the stack?  Perhaps more importantly, how do we know, when reading the source code, if @ is a message or just the normal Forth word fetch?  Bar may be, for example, a rectangle object and the @ message may return four items on the stack (top, left, bottom, and right coordinates).  It is very simple to avoid such confusion by adopting the recommended message naming convention.If there is a name conflict with another word that ends in colon then that conflict should be handled as would any Forth naming conflict.  For example if we name a selector FIELD: (not a good idea, really) and our Forth system reports that we have just redefined FIELD: then we can either ignore the redefinition or choose another name for our message.  Simple.  You may want to observe the "redefined" warnings issued by your Forth system when compiling an FMS class that makes new message names.- Methodless ivar access.  Conventional OOP practice would dictate that the data contained in an object must *only* be accessed via a message send to the object.  This provides a level of security for a program's data.  At one time I felt strongly about this and always required message sends.  But others have convinced me that it is probably more in the Forth tradition to allow data access without having to define accessor messages.  So we have provided for methodless access in FMS.  I would simply say that one should use methodless ivar access with care.- There is a way to declare instance variables as members of records with a REC{ ... }REC  syntax.  Normally the ivars in an object each have a header that identifies the class of the ivar.  But you may want to use the ivar list as you would use a structures list, that is with nothing but data in contiguous cells (with perhaps padding for alignment).  Records allow you to easily do this.  The only restriction on ivars declared within a record is one cannot send late bound messages to the ivar (i.e., the class of the ivar contains methods that invoke late binding to [SELF]).  This should not be an issue as we expect only very basic fetch and store methods to be used on members of a record structure.- Objects may be instantiated as named dictionary-based or as nameless heap-based.- Implicit initialization of objects and all of an object's ivars (including ivars of any superclasses) is the default using the INIT: message.- Indexed (one dimension) objects/ivars are explicitly supported.  This allows for a very convenient way to allot/allocate a contiguous list of data for an object or an object's ivars.- Error checking for invalid message sends and out of bounds indices are provided if the constant ERRORCHECK is set to true.- When defining a class, a superclass must always be provided using <SUPER <classname> or SUPER{ <classname1> <classname2> <classname3 >... } in multiple inheritance.- Arrays of a class of objects can be easily created in the dictionary using objArray()  example:  :class point      var x     var y   :m show: x @ . y @ . ;m  ;class20 objArray() point points()0 points() show:1 points() show:...- PUBLIC and PRIVATE declarations for methods or ivars are not supported (but they could be).  Especially with methodless ivar access, I do not see the point in trying to make code more "secure" by using PUBLIC and PRIVATE.- Class instance variables are not supported (but they could be).  FMS is open and extensible.========WHY OOP?========Some claim that the main value of object programming is for creating graphical user interfaces.  While useful for that, there is no reason to limit OOP use to GUIs.  Some of the important benefits of object programming include (but are not limited to):  A higher order of information hiding and so easier handling of program complexity;  a consistent way to organize code;  a higher frequency of code reuse;  a significant reduction in the number of Forth words to be remembered.  For example, the *same* descriptive names for messages, such as size: or search:, can be reused for an unlimited variety of data types (objects).==================THE FMS USER WORDS==================The FMS user words are often the same as in Neon, but there are some very distinct differences in the usage of some of the words.  Below is a list of the FMS user words with a brief description of their purpose.  Stack effects are not shown.  A detailed usage glossary for these words, with stack effects, follows the list.1)  :CLASS       \ begin a class definition2)  <SUPER       \ declare the single superclass2a) SUPER{...}   \ declare the single superclass or multiple superclasses3)  ;CLASS       \ end a class definition4)  BYTES        \ ivar declaration primitive5)  :M           \ begin a method definition6)  ;M           \ end a method definition7)  SELF         \ pseudo-ivar for early-bound message to self8)  [SELF]       \ pseudo-ivar for late-bound message to self9)  SUPER        \ pseudo-ivar for message to superclass method10) SUPER>       \ directs message to a specific superclass11) OBJECT       \ the root class for all classes12) HEAP>        \ instantiate an object in the heap13) <FREE        \ free the memory of an object created with HEAP>14) IV           \ methodless access to an ivar while interpreting (see the "dot parser" syntax below: .. )15) [IV]         \ methodless access to an ivar while compiling (see the "dot parser" syntax below: .. )16) <INDEXED     \ declare a class as indexed17) IDXBASE      \ return the address of the indexed data in an object18) LIMIT        \ return the maximum number of indexed elements19) WIDTH        \ return the size in aus of an indexed element20) ^ELEM        \ return the address of an indexed element21) ?IDX         \ perform a validity check on an index21) MAKESELECT   \ create a selector outside of a method definition22) ERRORCHECK   \ user set-able compiler directive constant23) REC{         \ mark the beginning of a record list of ivars24) }REC         \ mark the end of a record list25) INIT:        \ this message will always be sent to the newly                 \ instantiated object and each of its ivars26) objArray()   \ instantiate an array of objects in the dictionary27) CLASS_AS>    \ force an early bound message send for efficiency if desired
28) ..           \ invoke the optional "dot parser" for methodless ivar access (can replace IV and [IV])29) DICT>        \ instantiate a nameless object in the dictionary
                 \ in a manner analogous to HEAP>================================================DESCRIPTIONS OF THE FMS USER WORDS AND THEIR USE================================================:CLASS ( "spaces<name>" -- )Begins the definition of a new class. This is a defining word. The name of the new class must come directly after :CLASS. The class name is later used in the following four ways. 1) At compile time to instantiate a dictionary object. Simply execute the class name and an unnamed dictionary object is returned on the stack.  The object can be, and usually is, then stored as a constant or in a value (or any place the programmer wishes to put it). 2) At run time to instantiate an unnamed object in the heap. See HEAP>. 3) To create ivar definitions in other class definitions.  These ivars then behave as embedded objects of the given class, responding to messages appropriately. 4) As a pseudo object. A message can be sent to a superclass name when the message is preceded by SUPER>.  This will result in use of the named superclass message. <SUPER ( "spaces<superclassname>" -- )Declares the superclass of a new class being defined.  <SUPER or SUPER{...} need not be supplied if the sole superclass is class OBJECT.  Otherwise, all classes must have an explicitly declared superclass(es).SUPER{ ... } ( "spaces<superclassname1>" "spaces<superclassname2>" "spaces<superclassname3>" -- )Declares the single superclass or the multiple superclasses of the new class being defined.  If omitted then "SUPER{ OBJECT }" is implicit.;CLASSEnds the definition of a class.BYTES  ( u "spaces<name>" -- )The sole primitive for defining new ivars. Bytes requires the size of the ivar, in addressable units and must be followed by the name of the ivar. Only used inside a class definition.:M  ( "spaces<name:>" -- methodXT )
:m <name> ... :m is analogous to ":" when creating a new colon definition.  For example: locals can be used as per normal if desired.:m begins a new method definition. Can only be used inside a class definition.  Performs three functions simultaneously: 1) Defines a new message name only if it has not previously been defined in any class (message names have global scope).  All message names must end in colon.  2) Defines the method that is to be invoked when an object or ivar of that class receives the given message. 3) Implicitly over rides, if necessary, existing methods in the superclass chain that are associated with the given message.;M  ( methodXT -- )Ends a method definition and stores the method's XT where it can be subsequently retrieved.  Analogous to ";" in a normal colon definition.SELF ( "spaces<messagename:>"-- )     or if no following message ( -- addr ) addr = base address of objectA pseudo ivar only used in method definitions. When it is the receiver of a message it will compile an early bound message send using the method that has already been defined either in the current class or in the superclass chain hierarchy.  When used without a message it will simply return the base address of the object.[SELF] ( "spaces<messagename:>" -- )A pseudo ivar only used in method definitions. When it receives a message it will compile it as a late bound send using the method that has already been defined either in the current class or in the subclass chain hierarchy. [SELF] should only be used with a following message.SUPER ( "spaces<messagename>" --  )A pseudo ivar only used in method definitions. As the receiver of a message it will compile the method that has already been defined one level up in the superclass chain hierarchy, skipping over the already defined method in the current class definition.  SUPER must be followed by a message name.  If the <messagename> method has not been redefined then this use of SUPER will be equivalent to the use of SELF (in this case it would be clearer to just use SELF instead of SUPER).SUPER> ( "spaces<classname>" "spaces<messagename>" -- )Similar to SUPER except that a method of any primary superclass can be used.  Note that SUPER> will only work with *primary* superclasses of the class being defined in the case of multiple inheritance.  In the case of single inheritance SUPER> can be used with *any* superclass up the inheritance chain.HEAP>   ( "spaces<classname>" -- ^obj )Instantiates a nameless object on the heap. Must be followed by the name of a class and will return an object pointer. <FREE must be used to return the object's memory to the heap.  HEAP> is a compile time only word. It cannot be used outside a word definition.<FREE  ( ^obj -- )Returns a heap object's memory to the heap.  See HEAP> above.

DICT>   ( "spaces<classname>" -- ^obj )Instantiates a nameless object in the dictionary. Must be followed by the name of a class and will return an object pointer.  DICT> is a compile time only word. It cannot be used outside a word definition.IV ( ^obj -- ivar-addr ) \ input stream: "spaces<ivarname>"Provides methodless access to the ivars of an object.  Interpret use only, cannot be compiled.  Essentially a programmer's convenience tool.[IV] ( ^obj -- ivar-addr ) \ input stream: "spaces<ivarname>"Version of IV for to be used for compilation state.

.. 
Invokes the dot parser.  Provides a shorthand syntax for methodless ivar accessing (ref. IV and [IV]).
Consider the following:

:class var 
  cell bytes data
:m @: ( -- n ) data @ ;m
;class

:class point 
  var x
  var y
;class

:class rectangle 
  point upperLeft
  point lowerRight
;class

rectangle r

\ methodless ivar access with the dot parser:

.. r.lowerRight.x @ . \ for a var object we can use the @ primitive

\ or send a message:.. r.lowerRight.x @: .

orr .. .lowerRight.x @ .\ methodless ivar access of a heap object with the dot parser:: make heap> rectangle ; make value hr67 hr .. .lowerRight.y !

Note that you may want to automatically invoke the dot parser without having to use the ".." prefix.  Since this cannot be done in an ANS way you must adapt it to your particular Forth.  In MacForth and VFXForth this has been done using their respective "unknown-word" interpreter/compiler utilities.
<INDEXED ( width -- )Declares the class as an indexed class with each element having the indicated width in aus.  Instantiating an indexed class requires declaring the number of indexed elements at the time of object instantiation.  All subclasses of this class will have an indexed ivar data area of the same width and <INDEXED need not (should not) be used again.  Subclasses will *always* have indexed widths that are the same as the superclass.  Classes using multiple inheritance may have just one of the superclasses be an indexed class.  If one of the superclasses is indexed, then the subclasses will automatically be indexed and will have the same WIDTH as the superclass.  Width may not be changed in subclasses.  Refer to the class definitions of 1-ARRAY and 2-ARRAY in the file fmsLib.f for very straightforward examples of how <INDEXED and the following array primitive FMS words are used.IDXBASE ( -- addr )Can only be used inside a class definition.  Also, can only be used if the class or a superclass has been declared as indexed with <INDEXED.  Returns the address of the beginning of the indexed ivar data in an object.  See example class dicArray for an example of use.LIMIT ( -- n )Can only be used inside a class definition.  Also, can only be used if the class or a superclass has been declared as indexed with <INDEXED.  Returns the maximum number of elements in an indexed object.  See example class dicArray for an example of use.WIDTH ( -- n )Can only be used inside a class definition.  Also, can only be used if the class or a superclass has been declared as indexed with <INDEXED.  Returns the width in aus of the elements in an indexed object.  See example class dicArray for an example of use.^ELEM ( index -- addr )Can only be used inside a class definition.  Also, can only be used if the class or a superclass has been declared as indexed with <INDEXED.  Returns the addr of the element(index) in an indexed object.  See example class dicArray for an example of use.?IDX ( index -- index )Can only be used inside a class definition.  Also, can only be used if the class or a superclass has been declared as indexed with <INDEXED.  Performs an error check for validity of the index *only* if the global compiler constant ERRORCHECK is set to TRUE.  See example class dicArray for an example of use.MAKESELECT ( "spaces<name:>" -- ) The recommended way to create a new selector that is not immediately associated with any method.  Can be used inside or outside a class definition.  As long as the message is only used as late bound ( such as  '  [self] message:  ' ) then compilation will proceed as expected.  But before the message is actually sent at run time there must be a method defined for the selector (or message).  See example class SEQUENCE for how this may be used.FMSCHECK?  ( -- flag )A constant used as a compiler directive.  If set to TRUE, which is recommended during development, then error checking will be performed for the validity of messages sent to objects/ivars and error checking will be performed for the validity of an index sent to an indexed object via ?IDX.  After a program has been debugged, it should then be recompiled with errorcheck set to false for somewhat faster program execution.REC{  ( -- )Used in the ivar declaration list in a class definition.  Marks the beginning of a record.  The following list of ivars will comprise a contiguous list of data, essentially as in a structure list.  The record list is ended with }REC.  It is important to know that late-bound messages may *not* be sent to members of a record.}REC  ( -- )Used to mark the end of a record list.   See REC{ above.CLASS_AS> ( ^obj -- <varies> )   \ this is a compile-time-only word   \ Input stream:  "spaces<classname>" "spaces<messagename>" Used to force early binding.  If you need the extra speed of early binding *and* you know the class of the object on the stack then CLASS_AS> can be used.  This syntax is borrowed from PowerMops.  Since this is a speed optimization word it is only valid for use inside a definition (this minimizes state-smart words as well).INIT: ( -- ) \ strongly recommend that INIT: not consume or return stack itemsI believe that a proper object system should have a default initialization method that is automatically invoked whenever an object is instantiated.  In FMS we use the INIT: message.  Class OBJECT, the root class of all classes, has a default INIT: method which does nothing so it is not necessary to define an INIT: method unless you need it.  Also, years ago in Mops it was observed that any explicit call to INIT: was always preceded by a call to SUPER INIT: (actually, in Mops/PowerMops it would be CLASSINIT: SUPER ).  Therefore it was decided that whenever an INIT: method was defined then the object system would also automatically call SUPER INIT: "prior" to sending the INIT: message to the newly created object.  If the SUPER INIT: call was not wanted, then one could undo what it did in the INIT: method of the object's class.  This behavior might best be also explained by an example as follows:

:class var1   cell bytes data1:m init: -1 data1 ! ;m:m @: ( -- n) data1 @ ;m;classvar1 v1v1 @: . -1 ok  \ object v1 will automatically be instantiated to -1Now consider a subclass of var1::class var2 <super var1  cell bytes data2:m init: 2 data2 ! ;m:m @: ( -- n1 n2 ) data1 @ data2 @ ;m;classvar2 v2v2 @: swap . . -1 2 ok  \ we see that ivar data1 was implicitly initializedFrom object v2's response to the @: message we can see that v2's superclass data (data1) was indeed also sent the INIT: method implicitly.  But what if we don't want data1 to be set to -1 in a subclass?  Simply override as follows::class var3 <super var1  cell bytes data2:m init: 2 data2 ! 0 data1 ! ;m \ override the implicit super init::m @: ( -- n1 n2 ) data1 @ data2 @ ;m;classvar3 v3v3 @: swap . . 0 2 ok  \ we see that we can override the implicit init: of data1Note that an INIT: method is not allowed to consume or return stack items.  The reason for this is that in doing so one then makes it impossible to use that class for embedded ivars.  There is no way to pass parameters to or receive parameters from ivars when the ivar is instantiated.  If you need to perform some special object initialization each time an object is instantiated, and you cannot do this via a custom "INIT:" method by simply naming it something like "SETUP: ( a b -- ) ..." and invoke that explicitly each time you instantiate an object (this assumes you need a and b to be different for each object).objArray() instantiation time: ( #objects -- )             or if indexed:    ( #objects #elems -- )           input stream: "<spaces>className" "<spaces>name()"           run time execution of name():  ( idx -- ^obj(idx) )Note that if the fmsCheck? flag is true then the index passed to "name()" will be checked for validity.


==================
STRUCTURES AND FMS
==================
FMS ivar records are 100% compatible with Forth 200x structures:
begin-structure point  1 cells +field p.x  1 cells +field p.yend-structurebegin-structure rect   point +field r.tl  point +field r.br end-structure:class structTest <super object  rect bytes irect ;classstructTest tt . 16873864 t r.tl p.x . 16873864 t r.tl p.y . 16873868 t r.br p.x . 16873872 t r.br p.y . 16873876


==============================
FSL STYLE INFIX ARRAY NOTATION
==============================

FMS arrays can easily use a FSL-like infix syntax :

: }^ ( ^obj n -- addr{ n } ) \ word that fetches 1-D array element address
  swap ^elem: ;
: }@ ( ^obj n -- elem{ n } ) \ word that fetches 1-D array element contents
  swap at: ;

: }}^ ( ^obj row col -- addr{ r c } ) \ word that fetches 2-D array element address
  rot ^elem: ;
: }}@ ( ^obj row col -- elem{ r c } ) \ word that fetches 2-D array element contents
  rot at: ;

3 ordered-col oc{

oc{ 0 }^ . 16888596 
oc{ 0 }@ . 0 
oc{ 1 }^ . 16888600 
oc{ 1 }@ . 0
=========USING FMS=========The following FMS code example should give you an idea of what programming in FMS is like.  Note the syntax similarities to Neon and Mops, including simple use of embedded objects as ivars in class definitions.  Also note the object-message syntax.\ Begin definition of a new class, named var. The superclass is implicitly set to OBJECT.:class var   cell bytes data  \ define an ivar, named data, using the bytes primitive :m !: ( n -- ) data ! ;m  \ ivar addr is obtained by executing its name :m +: ( n -- ) data +! ;m :m @: ( -- n )  data @ ;m :m p: ( -- )   [self] @: . ;m \ print self, late bound;classvar x    \ Instantiate an object in the dictionary named x.45 x !:  \ Store 45 in object x by sending the !: message.x p:  \ Print object x by sending the p: message.45 :class point   var x  \ ivar as embedded object of class var  var y  :m show:        x p:  \ access ivar via message send        y @ . \ methodless ivar access inside a class definition        ;m   :m dot: ." Point at "  [self] show: ;m  \ this is a late bind of show: to self;class point origin  \ instantiate a point object named origin\ methodless ivar access outside a class definition5 origin IV x !8 origin IV y !

\ or alternatively use the dot parser
5 .. origin.x !8 .. origin.y !origin dot:  \ send the dot: message to originPoint at 5 8 :class rectangle <super object    point ul  point lr  :m show: ul dot:  lr dot: ;m  :m dot: ." Rectangle, "  self show: ;m \ this is an early bind of show: to self;class rectangle rr dot:Rectangle, Point at 0 0 Point at 0 0 :class label-point <super point \ the superclass is class point  :m show: ." X" x @ .  ." Y" y @ .  ;m;class label-point poopoo dot: Point at X0 Y0 \ demonstrates that show: is late-bound in class point ===================================THE FULL CLASS TEMPLATE DESCRIPTION===================================So the full standard template for creating a class is familiar and is as follows::CLASS myClass SUPER{ mySuperclass1 mySuperclass2 ... } ( <INDEXED declaration is optional )  n BYTES     myIvar1   \ create an ivar using the bytes primitive  myExistingClass myIvar2   \ create an ivar using a pre-defined class rec{                      \ begin an ivar record section   myExistingClass myIvar3   myExistingClass myIvar4   }rec                    \ end an ivar record section  myExistingClass myIvar5   \ create an ivar using a pre-defined class (not a record)    :M myMessage: ...  ;M  \ create a message and method and associate the two for this class:CLASS  \ end the class definitionmyClass myObject  \ instantiate an object in the dictionary, named myObjectmyObject myMessage: \ send a message to the dictionary objectHEAP> and <FREE are used to instantiate objects in the heap and free the memory when done.0 value myHeapObject: test HEAP> myClass to myHeapObject ;  \ instantiate an object in the heapmyHeapObject myMessage: \ send a message to the heap objectmyHeapObject <FREE \ free the memory of the heap objectIVAR ACCESSThere are four techniques for doing this in FMS.  Consider the following class definition::class Circle     var radius   point center\ the primitive DrawCircle requires ( x y radius ) as input :m draw: center @: ( x y ) radius @: ( x y r ) DrawCircle ;m;classClearly there must be a way to set the radius and center of a circle object.  We have four.1) Just declare the ivar and access it via @ ! C@ F@ etc., one must know the size of the ivar so that the correct Forth operator is used.:class Circle     var radius   point center :m draw: center @: ( x y )     \ ivar access via message send          radius @ DrawCircle   \ ivar access via normal Forth word @     ;m :m set: ( x y r -- ) radius ! point !: ;m;class2) Define methods for ivar access.:class Circle     var radius   point center :m draw: center @: ( x y ) radius @: DrawCircle ;m :m set: ( x y r -- ) radius !: point !: ;m;class3) Use methodless ivar access *after* an object has been instantiated.  \ The dot parser is an alternative to using IV and [IV].:class Circle     var radius   point center :m draw: center @: ( x y ) radius @: DrawCircle ;m;classCircle c10 c iv radius !25 c iv radius !: 

or10 .. c.radius !25 .. c.radius !: 
4) Cut and paste the ivar declarations such that they precede the class definition.  This can be useful during development.  Note that a public object declaration is identical to that for an ivar declaration.  The only difference is "where" the object/ivar is declared (inside or outside of a class definition).   var radius   point center:class Circle  :m draw: center @: ( x y ) radius @: DrawCircle ;m;classCircle c10 20 center !:25 radius !:c draw: Once the class is debugged just cut and paste the radius and center declarations back inside the class definition where they belong.